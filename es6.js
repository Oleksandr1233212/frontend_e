> Дмитро Ващишин:
// Посібник з ES6 з детальними коментарями

// Зміст
//
// 1. Let та Const
// 2. Стрілкові функції (Arrow Functions)
// 3. Шаблонні літерали (Template Literals)
// 4. Параметри за замовчуванням (Default Parameters)
// 5. Оператор розпакування та залишкові параметри (Spread and Rest Operators)
// 6. Деструктуризація (Destructuring Assignment)
// 7. Покращені літерали об'єктів (Enhanced Object Literals)
// 8. Класи (Classes)
// 9. Проміси (Promises)
// 10. Модулі (Modules)
// 11. Цикл for...of
// 12. Символи (Symbols)
// 13. Колекції Map та Set
// 14. WeakMap та WeakSet
// 15. Ітератори та Генератори
// 16. Нові методи для рядків та масивів
// 17. Параметри залишку та розпакування для об'єктів
// 18. Символічні властивості в об'єктах
// 19. Нові методи об'єктів
// 20. Функції вищого порядку

// ------------------------------------------------------------------------------------------------------
// 1. Let та Const
// let та const дозволяють оголошувати змінні з блоковою областю видимості.

// Приклад 1: Використання let
// Оголошуємо змінну 'x' зі значенням 10
let x = 10;

if (true) {
  // Ця змінна 'x' існує лише в цьому блоці
  let x = 20;
  console.log(x); // Виведе: 20
}

console.log(x); // Виведе: 10
// Зовнішня змінна 'x' залишилася незмінною

// Пояснення:
// - let дозволяє оголошувати змінні, які дійсні лише в межах блоку {}.
// - У прикладі ми маємо дві змінні з ім'ям x, але вони знаходяться в різних областях видимості.

// Приклад 2: Використання const
// Оголошуємо константу 'PI' зі значенням 3.14
const PI = 3.14;
console.log(PI); // Виведе: 3.14

// Спроба змінити значення константи призведе до помилки
// PI = 3.1415; // Помилка: Assignment to constant variable.

// Пояснення:
// - const використовується для оголошення констант — змінних, значення яких не можна змінити.
// - Константи повинні бути ініціалізовані під час оголошення.

// ------------------------------------------------------------------------------------------------------
// 2. Стрілкові функції (Arrow Functions)
// Стрілкові функції надають короткий синтаксис для оголошення функцій та лексично зв'язують this.

// Приклад 1: Просте використання
// Звичайна функція
function add(a, b) {
  return a + b;
}

// Стрілкова функція
const addArrow = (a, b) => a + b;

console.log(add(2, 3));      // Виведе: 5
console.log(addArrow(2, 3)); // Виведе: 5

// Пояснення:
// - Стрілкові функції дозволяють писати функції коротше.
// - Якщо функція виконує лише одне вираження, можна опустити фігурні дужки та ключове слово return.

// Приклад 2: Лексичне this
const student = {
  name: 'Оля',
  subjects: ['математика', 'фізика', 'хімія'],
  listSubjects() {
    this.subjects.forEach((subject) => {
      // 'this' посилається на об'єкт 'student'
      console.log(`${this.name} вивчає ${subject}`);
    });
  },
};

student.listSubjects();
// Виведе:
// Оля вивчає математика
// Оля вивчає фізика
// Оля вивчає хімія

// Пояснення:
// - Стрілкові функції не мають власного this.
// - this всередині стрілкової функції бере значення з зовнішньої області видимості.

// ------------------------------------------------------------------------------------------------------
// 3. Шаблонні літерали (Template Literals)
// Шаблонні літерали дозволяють вставляти змінні та вирази в рядки, а також створювати багаторядкові рядки.

// Приклад 1: Інтерполяція змінних
const name = 'Максим';
const age = 15;

const greeting = Привіт, мене звати ${name}, і мені ${age} років.;
console.log(greeting);
// Виведе: Привіт, мене звати Максим, і мені 15 років.

// Пояснення:
// - Використовуємо зворотні апострофи ` для створення шаблонного літерала.
// - Вставляємо змінні та вирази за допомогою ${...}.

// Приклад 2: Багаторядкові рядки
const message = `Це приклад
багаторядкового
рядка.`;


console.log(message);
// Виведе:
// Це приклад
// багаторядкового
// рядка.

// Пояснення:
// - Шаблонні літерали зберігають переноси рядків та пробіли, що робить їх зручними для довгих текстів.

> Дмитро Ващишин:
// ------------------------------------------------------------------------------------------------------
// 4. Параметри за замовчуванням (Default Parameters)
// Дозволяють встановлювати значення параметрів функції за замовчуванням.

// Приклад 1: Функція з параметром за замовчуванням
function greet(name = 'Гість') {
  console.log(`Привіт, ${name}!`);
}

greet();          // Виведе: Привіт, Гість!
greet('Влад');    // Виведе: Привіт, Влад!

// Пояснення:
// - Якщо при виклику функції не передано аргумент, параметр name матиме значення 'Гість'.

// Приклад 2: Параметри за замовчуванням у математичній функції
function power(base, exponent = 2) {
  return base ** exponent;
}

console.log(power(3));      // Виведе: 9 (3 в степені 2)
console.log(power(3, 3));   // Виведе: 27 (3 в степені 3)

// Пояснення:
// - Якщо не вказати другий параметр exponent, він матиме значення 2.

// ------------------------------------------------------------------------------------------------------
// 5. Оператор розпакування та залишкові параметри (Spread and Rest Operators)
// Оператор ... використовується для розпакування масивів або об'єктів та збирання залишкових параметрів.

// Приклад 1: Розпакування масиву
const numbers = [1, 2, 3];
const newNumbers = [...numbers, 4, 5];

console.log(newNumbers);
// Виведе: [1, 2, 3, 4, 5]

// Пояснення:
// - Оператор ... розпаковує елементи масиву numbers в новий масив newNumbers.

// Приклад 2: Залишкові параметри у функції
function multiply(multiplier, ...args) {
  return args.map((num) => num * multiplier);
}

const result = multiply(2, 1, 2, 3);
console.log(result);
// Виведе: [2, 4, 6]

// Пояснення:
// - Параметр ...args збирає всі додаткові аргументи у масив.
// - Функція множить кожен елемент масиву args на multiplier.

// ------------------------------------------------------------------------------------------------------
// 6. Деструктуризація (Destructuring Assignment)
// Дозволяє розпаковувати значення з масивів або властивості з об'єктів у окремі змінні.

// Приклад 1: Деструктуризація масиву
const colors = ['червоний', 'зелений', 'синій'];
const [firstColor, secondColor, thirdColor] = colors;

console.log(firstColor);   // Виведе: червоний
console.log(secondColor);  // Виведе: зелений
console.log(thirdColor);   // Виведе: синій

// Пояснення:
// - Розпаковуємо елементи масиву colors у змінні firstColor, secondColor, thirdColor.

// Приклад 2: Деструктуризація об'єкта
const user = {
  username: 'user123',
  email: 'user@example.com',
  password: 'secret',
};

const { username, email } = user;

console.log(username); // Виведе: user123
console.log(email);    // Виведе: user@example.com

// Пояснення:
// - Розпаковуємо властивості об'єкта user у змінні username та email.

// ------------------------------------------------------------------------------------------------------
// 7. Покращені літерали об'єктів (Enhanced Object Literals)
// Дозволяють спрощувати синтаксис при створенні об'єктів.

// Приклад 1: Скорочений запис властивостей
const namePerson = 'Світлана';
const agePerson = 17;

const person = { namePerson, agePerson };

console.log(person);
// Виведе: { namePerson: 'Світлана', agePerson: 17 }

// Пояснення:
// - Якщо назва змінної збігається з назвою властивості, можна записати лише назву змінної.

// Приклад 2: Оголошення методів без function
const calculator = {
  add(a, b) {
    return a + b;
  },
  subtract(a, b) {
    return a - b;
  },
};

console.log(calculator.add(5, 3));       // Виведе: 8
console.log(calculator.subtract(5, 3));  // Виведе: 2

// Пояснення:
// - Методи об'єкта можна оголошувати без ключового слова function.

// ------------------------------------------------------------------------------------------------------
// 8. Класи (Classes)
// Класи надають зручний спосіб створення об'єктів та реалізації наслідування.









// Приклад 1: Оголошення класу
class Animal {
  constructor(name) {
    this.name = name;
    this.age = age
  }

  speak() {
    console.log(`${this.name} видає звук.`);
  }
}

> Дмитро Ващишин:
const animal = new Animal('Лев');
animal.speak();
// Виведе: Лев видає звук.

// Пояснення:
// - class — ключове слово для оголошення класу.
// - constructor — спеціальний метод для ініціалізації об'єкта.
// - Методи класу оголошуються без ключового слова function.

// Приклад 2: Наслідування класів
class Dog extends Animal {
  constructor(name, breed) {
    super(name); // Викликаємо конструктор батьківського класу
    this.breed = breed;
  }

  speak() {
    console.log(`${this.name} гавкає.`);
  }
}

const dog = new Dog('Бім', 'Вівчарка');
dog.speak();
// Виведе: Бім гавкає.

// Пояснення:
// - extends використовується для наслідування від іншого класу.
// - super викликає конструктор батьківського класу.

// Приклад 3: Статичні методи
class MathHelper {
  static square(number) {
    return number * number;
  }
}

console.log(MathHelper.square(5)); // Виведе: 25

// Пояснення:
// - static методи викликаються безпосередньо на класі, а не на його екземплярі.

// Приклад 4: Геттери та сеттери
class Rectangle {
  constructor(width, height) {
    this.width = width;
    this.height = height;
  }

  // Геттер для площі
  get area() {
    return this.width * this.height;
  }

  // Сеттер для встановлення площі, зберігаючи пропорції
  set area(value) {
    const ratio = Math.sqrt(value / this.area);
    this.width *= ratio;
    this.height *= ratio;
  }
}

const rect = new Rectangle(4, 9);
console.log(rect.area); // Виведе: 36

rect.area = 100;
console.log(rect.width);  // Нове значення ширини
console.log(rect.height); // Нове значення висоти

// Пояснення:
// - get та set дозволяють оголошувати геттери та сеттери для властивостей.

// Приклад 5: Приватні поля (ES2022 та пізніше)
class BankAccount {
  #balance = 0; // Приватне поле

  deposit(amount) {
    this.#balance += amount;
    console.log(`Баланс поповнено на ${amount}. Поточний баланс: ${this.#balance}`);
  }

  withdraw(amount) {
    if (amount <= this.#balance) {
      this.#balance -= amount;
      console.log(`Знято ${amount}. Залишок: ${this.#balance}`);
    } else {
      console.log('Недостатньо коштів.');
    }
  }
}

const account = new BankAccount();
account.deposit(500); // Виведе: Баланс поповнено на 500. Поточний баланс: 500
account.withdraw(200); // Виведе: Знято 200. Залишок: 300
// account.#balance; // Помилка: приватне поле недоступне ззовні

// Пояснення:
// - # перед назвою поля робить його приватним і недоступним за межами класу.

// ------------------------------------------------------------------------------------------------------
// 9. Проміси (Promises)
// Проміси використовуються для роботи з асинхронними операціями.

// Приклад 1: Створення та використання проміса
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Дані успішно завантажені.');
  }, 2000);
});

promise.then((message) => {
  console.log(message); // Виведе: Дані успішно завантажені. (через 2 секунди)
});

// Пояснення:
// - Проміс — це об'єкт, який представляє завершення або невдачу асинхронної операції.
// - resolve — викликається при успішному завершенні.
// - reject — викликається при помилці.

// Приклад 2: Ланцюжок промісів
function fetchData() {
  return new Promise((resolve) => {
    setTimeout(() => resolve(10), 1000);
  });
}

fetchData()
  .then((number) => {
    console.log(number); // Виведе: 10
    return number * 2;
  })
  .then((number) => {
    console.log(number); // Виведе: 20
    return number * 3;
  })
  .then((number) => {
    console.log(number); // Виведе: 60
  });

// Пояснення:
// - Кожен .then() отримує значення, повернене з попереднього .then().

// ------------------------------------------------------------------------------------------------------
// 10. Модулі (Modules)
// Дозволяють організовувати код у різних файлах та імпортувати/експортувати функціонал.

// Приклад 1: Експорт та імпорт функції
// Файл: math.js
export function add(a, b) {
  return a + b;
}

export const PI = 3.14159;

// Файл: main.js
import { add, PI } from './math.js';

> Дмитро Ващишин:
console.log(add(2, 3)); // Виведе: 5
console.log(PI);        // Виведе: 3.14159

// Пояснення:
// - export використовується для експорту змінних або функцій.
// - import використовується для імпорту цих змінних або функцій в інший файл.

// Приклад 2: Експорт за замовчуванням
// Файл: student.js
export default class Student {
  constructor(name) {
    this.name = name;
  }
}

// Файл: main.js
import Student from './student.js';

const studentInstance = new Student('Ірина');
console.log(studentInstance.name); // Виведе: Ірина

// Пояснення:
// - export default використовується для експорту одного основного елемента з файлу.
// - При імпорті можна називати змінну будь-яким ім'ям.

// ------------------------------------------------------------------------------------------------------
// 11. Цикл for...of
// Дозволяє ітерувати ітеративні об'єкти (масиви, рядки тощо).

// Приклад 1: Ітерація по масиву
const scores = [90, 85, 100];

for (const score of scores) {
  console.log(score);
}
// Виведе:
// 90
// 85
// 100

// Пояснення:
// - for...of проходить по кожному елементу масиву scores.

// Приклад 2: Ітерація по рядку
const text = 'JavaScript';

for (const char of text) {
  console.log(char);
}
// Виведе:
// J
// a
// v
// a
// S
// c
// r
// i
// p
// t

// Пояснення:
// - for...of може використовуватися для ітерації по символах рядка.

// ------------------------------------------------------------------------------------------------------
// 12. Символи (Symbols)
// Унікальні та незмінні ідентифікатори, які можуть використовуватися як ключі властивостей об'єкта.

// Приклад 1: Створення символів
const symbol1 = Symbol('опис');
const symbol2 = Symbol('опис');

console.log(symbol1 === symbol2); // Виведе: false
// Навіть з однаковим описом, символи завжди унікальні

// Пояснення:
// - Символи створюються за допомогою функції Symbol().
// - Використовуються для уникнення конфліктів імен властивостей.

// Приклад 2: Використання символів як ключів об'єкта
const ID = Symbol('id');

const userSymbol = {
  name: 'Дмитро',
  [ID]: 12345,
};

console.log(userSymbol[ID]); // Виведе: 12345

// Пояснення:
// - Властивості з ключами-символами не будуть випадково перезаписані та не відображаються при звичайній ітерації.

// ------------------------------------------------------------------------------------------------------
// 13. Колекції Map та Set
// Нові структури даних для зберігання пар ключ-значення та унікальних значень.

// Приклад 1: Використання Map
const map = new Map();

map.set('ключ1', 'значення1');
map.set('ключ2', 'значення2');

console.log(map.get('ключ1')); // Виведе: значення1
console.log(map.size);         // Виведе: 2

// Пояснення:
// - Map дозволяє використовувати будь-які типи даних як ключі.

// Приклад 2: Використання Set
const set = new Set();

set.add(1);
set.add(2);
set.add(2); // Дублікати ігноруються

console.log(set.has(2)); // Виведе: true
console.log(set.size);   // Виведе: 2

// Пояснення:
// - Set зберігає лише унікальні значення.

// ------------------------------------------------------------------------------------------------------
// 14. WeakMap та WeakSet
// Колекції, які дозволяють збирати невикористовувані об'єкти сміттєзбиральником.

// Приклад 1: WeakMap
let obj = { name: 'Катерина' };
const weakMap = new WeakMap();

weakMap.set(obj, 'Дані про Катерину');
console.log(weakMap.get(obj)); // Виведе: Дані про Катерину

obj = null; // Об'єкт може бути видалений з пам'яті
// weakMap автоматично видалить запис про 'obj'

// Пояснення:
// - WeakMap дозволяє сміттєзбиральнику видаляти записи, якщо ключ об'єкт стає недоступним.

// Приклад 2: WeakSet
let userWeak = { id: 1 };
const weakSet = new WeakSet();

weakSet.add(userWeak);
console.log(weakSet.has(userWeak)); // Виведе: true

userWeak = null; // Об'єкт може бути видалений з пам'яті
// weakSet автоматично видалить запис про 'userWeak'

// Пояснення:
// - WeakSet працює лише з об'єктами та не перешкоджає їх видаленню з пам'яті.

> Дмитро Ващишин:
// ------------------------------------------------------------------------------------------------------
// 15. Ітератори та Генератори
// Дозволяють створювати власні ітеративні об'єкти.

// Приклад 1: Ітератор
const iterableObj = {
  [Symbol.iterator]() {
    let step = 0;
    return {
      next() {
        step++;
        if (step === 1) {
          return { value: 'Перший крок', done: false };
        } else if (step === 2) {
          return { value: 'Другий крок', done: false };
        }
        return { value: undefined, done: true };
      },
    };
  },
};

for (const val of iterableObj) {
  console.log(val);
}
// Виведе:
// Перший крок
// Другий крок

// Пояснення:
// - Об'єкт iterableObj має метод [Symbol.iterator](), який повертає ітератор з методом next().

// Приклад 2: Генератор
function* generatorFunction() {
  yield 'Перший крок'; 
  yield 'Другий крок';
  yield 'Третій крок';
}

const generator = generatorFunction();

console.log(generator.next().value); // Виведе: Перший крок
console.log(generator.next().value); // Виведе: Другий крок
console.log(generator.next().value); // Виведе: Третій крок
console.log(generator.next().done);  // Виведе: true

// Пояснення:
// - Генератори спрощують створення ітераторів за допомогою функції з * та ключового слова yield.

// ------------------------------------------------------------------------------------------------------
// 16. Нові методи для рядків та масивів
// Додано корисні методи для роботи з рядками та масивами.

// Приклад 1: Метод includes для рядків
const sentence = 'Навчаємося програмувати на JavaScript';

console.log(sentence.includes('програмувати')); // Виведе: true
console.log(sentence.includes('Python'));       // Виведе: false

// Пояснення:
// - includes() перевіряє, чи містить рядок вказаний підрядок.

// Приклад 2: Метод find для масивів
const numbersArray = [5, 12, 8, 130, 44];

const found = numbersArray.find((element) => element > 10);
console.log(found); // Виведе: 12

// Пояснення:
// - find() повертає перший елемент, що задовольняє умову в колбек-функції.

// ------------------------------------------------------------------------------------------------------
// 17. Параметри залишку та розпакування для об'єктів
// Дозволяють копіювати або об'єднувати об'єкти.

// Приклад 1: Розпакування об'єкта
const personObj = { name: 'Сергій', age: 18 };
const clonedPerson = { ...personObj };

console.log(clonedPerson);
// Виведе: { name: 'Сергій', age: 18 }

// Пояснення:
// - Оператор ... розпаковує властивості об'єкта person у новий об'єкт clonedPerson.

// Приклад 2: Залишкові параметри в об'єкті
const { name: personName, ...rest } = { name: 'Ліза', age: 20, city: 'Львів' };

console.log(personName); // Виведе: Ліза
console.log(rest);       // Виведе: { age: 20, city: 'Львів' }

// Пояснення:
// - Оператор ...rest збирає решту властивостей об'єкта в змінну rest.

// ------------------------------------------------------------------------------------------------------
// 18. Символічні властивості в об'єктах
// Символи можуть використовуватися як унікальні ключі властивостей.

// Приклад 1: Унікальні ключі
const UNIQUE_KEY = Symbol('unique');

const data = {
  [UNIQUE_KEY]: 'Секретна інформація',
};

console.log(data[UNIQUE_KEY]); // Виведе: Секретна інформація

// Пояснення:
// - Використання символів як ключів дозволяє уникнути конфліктів імен.

// Приклад 2: Уникнення конфліктів імен
const id1 = Symbol('id');
const id2 = Symbol('id');

const objSymbols = {
  [id1]: 'ID1',
  [id2]: 'ID2',
};

console.log(objSymbols[id1]); // Виведе: ID1
console.log(objSymbols[id2]); // Виведе: ID2

// Пояснення:
// - Навіть з однаковим описом, символи id1 та id2 різні та не перетинаються.

// ------------------------------------------------------------------------------------------------------
// 19. Нові методи об'єктів
// Додано методи для більш зручної роботи з об'єктами.

// Приклад 1: Object.assign
const target = { a: 1 };
const source = { b: 2, c: 3 };

const result = Object.assign(target, source);

> Дмитро Ващишин:
console.log(result); // Виведе: { a: 1, b: 2, c: 3 }

// Пояснення:
// - Object.assign() копіює властивості з одного або більше об'єктів у цільовий об'єкт.

// Приклад 2: Object.entries та Object.values
const objEntries = { x: 10, y: 20 };

console.log(Object.entries(objEntries)); // Виведе: [['x', 10], ['y', 20]]
console.log(Object.values(objEntries));  // Виведе: [10, 20]

// Пояснення:
// - Object.entries() повертає масив пар ключ-значення.
// - Object.values() повертає масив значень властивостей об'єкта.

// ------------------------------------------------------------------------------------------------------
// 20. Функції вищого порядку
// Функції, які приймають інші функції як аргументи або повертають їх.

// Приклад 1: Передача функції як аргументу
function sayHello(name) {
  console.log(`Привіт, ${name}!`);
}

function greetUser(callback) {
  const userName = 'Михайло';
  callback(userName);
}

greetUser(sayHello); // Виведе: Привіт, Михайло!

// Пояснення:
// - greetUser приймає функцію callback як аргумент і викликає її.

// Приклад 2: Функція, що повертає іншу функцію
function multiplier(factor) {
  return function (number) {
    return number * factor;
  };
}

const double = multiplier(2);
console.log(double(5)); // Виведе: 10

const triple = multiplier(3);
console.log(triple(5)); // Виведе: 15

// Пояснення:
// - multiplier повертає нову функцію, яка множить число на заданий фактор.

// ------------------------------------------------------------------------------------------------------
